NOTE : Source to see any topic : 1) graph playlist of striver 2) Pdf of codeism 3) Code written in Vs Code.

1) BFS :- this is written for an undirected/directed graph and an unweighted graph(agar weight ho bhi toh sare edge ka weight same hona chahiye), aur isme sare nodes ko exactly ek bar visit karte hai, level wise, graph can also contain cycles. Now in any question if you have to perform task step by step or level wise then try to apply bfs there and if you see cycles in the graph then also it can be used and how the algo is performed should be kept in mind, how we used queue, this use of queue how we used in bfs can be helpful in other places also. Can see code in graph2.cpp.

2) DFS :- it is basically recursion, the idea behind dfs is to go as deep into the graph as possible and backtrack once you are at a vertex with no unvisited adjacent nodes, in this we go to all the nodes for twice, once when we are moving in depth for a node until it has no unvisited adjacent nodes and once while we are backtracking the path from which we came to find if the visited nodes have some other neighbours or not, if it has then phir uske depth mein jate hai. It is for both directed and undirected graph. Also it can detect cycles in both directed and undirected graph. The code to detect cycle in directed and undirected graph is different. In question if you have a task to visit everything thing then this can be of use and if you see cycles in the graph then also it can be used, 
also in the question if you have the need to backtrack then also, it can be used.

NOTE :A)the standard way of applying bfs and dfs should be kept in mind as they will not be always useful to apply in graph only, can be applied in many other places also, so bfs and dfs lagane ka process yad rakhna hai.

CYCLE : We know that we start from different directions but can arrive at the same node only if the graph is connected or contains a cycle, otherwise we would never come to the same node again, i.e. in a graph if we started from one node and went in two different directions and arrived at the same node then there is a cycle so this fact can be used in undirected graphs to detect cycle using bfs and dfs, as => for a node if it's adjacent node is visited and it is not it's parent then there is a cycle as we came from two different directions to same node.

B) detecting cycle in undirected graph : both bfs and dfs can be used.

C) detecting cycle in a directed graph : only dfs can be used but also bfs can be used i.e. khan's algo can be used and in khan's algo we do use bfs also, for both B and C check graph11.cpp.

D) TOPOLOGICAL SORT : implemented with the help of bfs is known as khan's algorithm (we use queue and we keep putting nodes with indegree 0 in the queue until queue is empty and note if queue became empty before all the nodes pushed in the toposort vector means the graph is not a dag, it has some cycle so this is how cycle can also be detected using bfs) but it can also be implemented with the help of dfs(just use stack, topo sort is the order of nodes in decreasing order of their finishing times, so we do dfs from a node and once we find a node with no unvisited adjacent node we put it into the stack and finally just keep printing top of the stack to get the topological sorting) (g12.cpp and g13.cpp can be seen for this) and if you see cycles in the graph then also this algo can be used and also in topo sort as we require indegree, sometimes reversing the edges can also work and this can also be used in the questions it is somehow asked to do something in which somethings comes before something.

E)SHORTEST PATH IN DAG WHICH IS WEIGHTED : we need to perform 2 operations, getting the topo sort and then doing the relaxation operation(if there is an edge from u to v with weight w and d[u] + w < d[v] then d[v] = d[u] + w) and the intuition behind this is that, when we have topo sort order then we move sequentially while doing the relaxation operation. Code can be seen here : https://www.geeksforgeeks.org/problems/shortest-path-in-undirected-graph/1

F)SHORTEST PATH IN UNDIRECTED GRAPH : simply bfs run kar dena hai, with the help of queue, here we are just using queue and not a priority queue as the graph is unweighted and so in each iteration the distance increases by one only and not by different weights so, queue works as everything will be kept in increasing fashion, so we will get minimum distance only in each iteration, but in Dijkstra, in each interval, the distance increases by different weights and we want min of it which we will get by priority queue, declared as min heap, see graph15.cpp. Now in any question if we are asked to find shortest path may be to reach from one word to another or anything of that sort by doing some transformation, basically somehow we need shortest path then, this bfs using queue can be used as best thing of bfs is that it moves level wise.

3) DIJSKTRA'S ALGORITHM :- this can be used to find shortest distance as well as path from a source to destination for any weighted graph(may be cyclic, acyclic, directed, undirected) with egdes weight being non-negative, all the edges has to be strictly positive, otherwise it will give wrong results, so this is mainly for a weighted graph, the algorithm is made using priority queue which is by default based on max heap but we declare priority queue like this : priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; which now becomes a min heap, i.e. the if we pass thing as ({dis, node}) in the pq then smallest element will be on the top, and if dis for two element is same then node will be compared and smaller of the two will be kept at the top and then we have to run normal bfs in this pq which we have been doing and do the relaxation operation. Also this algo doesn't work for graph having negative weights as the algo will get stuck in an infinite loop. simply 2 node ke beech a negative weight put karke try this algo, it will stuck in an infinite loop. See graph 17.cpp or can also watch g-32 of striver playlist, also inplace of priority queue, set can be used as set already stores everything in ascending order so, st.begin() will already have the one with smallest distance if ({dis, node}) is fed in the set, also if for example node 5 has got distance 10 and is there in the set and now we got node 5 distance as 8 then we can easily erase {10, 5} from the set as now {8, 5} will be there in the set and we need to care about that only but this erase function could be used in pq so wo phir se pq mein {8, 5} pe kam karne ke bad {10, 5} pe jata which is useless, so this saves some iteration but still we can't say that this takes less time as erasing from set also take log(N) time, so this should just be kept in mind, also can see g-33 of striver playlist to understand this and most importantly also watch g-34 of striver playlist, it proves the time complexity of this algo and also tells us that yes we can also use queue in place of priority queue for this algo but why don't we prefer that. Time Complexity for Dijkstra's algo is ElogV. Now in questions where we need to find shortest path from one node to all the nodes in someway then this can be of use.

NOTE :A) DIJKSTRA'S ALGO : From question point of view, what we are inserting in the priority queue is most important, like if we are inserting something like {a, b, c} in pq then make sure we want to minimise a and minimising a is most important thing, also note if a is increasing in linear fashion then we can use queue also in place of priority queue, like this a can be dis, or any critical thing in the question and for eg if this dis is increasing in linear fashion then queue can also be used because us queue ke front mein hamesha min dis wala hi hoga. Also in question in which we have reach from some source to a destination then this algo can be used. Also note that after we pop something from pq, then is it even important for its node to put in pq or is it just increasing the time complexity, so we should keep this also in mind.

B) DIJKSTRA'S ALGO : Another important operation other than what is important to push in pq is the relaxation operation, now if we have put {a, b, c} in the pq so which of the following's relaxation will be done is critical and depends on the question, now may be we want to relax b, so vector<int> b karke ek array hoga and everytime when we pop b, we will try to relax it, as we did while finding shortest path in dag. so this this has to also kept in mind ki kisko relax karna hai. Also note from question point of view that while doing the relaxation operation we might have to store some information may be in some array or in some other data structure to get to the final result, which depends on the question, so while doing relaxation we can do such things.

4) BELLMAN FORD ALGORITHM :- Dijkstra was failing to compute shortest path when there was negative weight edges in the graph or there was a negative weight cycle (negative weight cycle in a graph is a cycle whose sum of all the weights is negative), but this doesn't fails, here we need to do only one operation, just do relaxation operation (if there is an edge from u to v with weight w and d[u] + w < d[v] then d[v] = d[u] + w), sequentially for n-1 times(n is the number of nodes) on each edge and the order of edges for each iteration of relaxation doesn't matter, we can relax in whatever order of edges is given in every iteration and we have to do so only for n-1 time. Now to know the reason why we need to do it for n-1 times only, see g-41 of striver graph playlist. Now if we did the relaxation for another Nth time and still the dis array(for instance) or d(whatever it is) gets relaxed then the graph must contain a negative weight cycle. see g-41 to know the reason. Also can see code at graph18.cpp. Also note that in this algo we use edges list in place of the adjacency list as we need to iterate through the edges list for n-1 times.

NOTE : A)BELLMAN FORD ALGORITHM : This code only works for directed graph and if undirected graph is given then we have to put that graph as directed graph in the adjacency list. Like if there is an undirected edge between 1 to 2 with edges weight 5 then edges.push_back({1, 2, 5}) and also edges.push_back({2, 1, 5}).
B) Now in the questions point of view if we need to find the shortest path from one node to all nodes in someway then this can be used and also if the edge weight is negative then we can think of it.

5) FLOYD WARSHALL ALGORITHM :- Given a directed or an undirected weighted graph G with n vertices. The task is to find the length of the shortest path d[i][j]  between each pair of vertices i and j and using this algorithm also we can detect negative cycle in the graph. The difference between dijkstra in this is that here we don't only find shortest path from a source to destination but from every node to every node we find the shortest path, hence it is also known as all pair shortest path algorithm. Here we use a adjancecy matrix and store in each iteration the shortest path from i to j via 1 in 1st iteration , then via 2 in second and so on until n. Hence 3 loops are used and so the time complexity is N^3 but if you used dijstra(if ther is no negative cycle in the graph) for each node then time complexity would be still less (n*elog(n) < n^3). Now this can also detect a negative cylcle in the graph, see the ulimate matrix which we get at the end, if in that for any node dis[node][node] is less than 0 that means there is a negative weight cylce in that as node to node distance should always be zero, negative cycle mein via all other nodes weight reduce hoke uss node(jiska node to node dis dekh rahe hai) pe aya hoga aur usko less than 0 kar dia hoga. can take simple example and see. Also can watch g-42 of striver and see graph19.cpp.

NOTE : A)The algorithm is not much intutive as the other ones. It is more of a brute force, where all combination of paths have been tried to get the shortest paths. Nothing to be panic much on the intution, it is a simple brute on all paths. Focus on the three (for Loops).
B) The algorithm is all pair shortest path so if in any question from every node to every node if we need to find the shortest path then this can be used.

6) DSU : In dsu by find_set operation we find the ultimate parent(root node) of any input node of the tree and while doing so we do path compression i.e. we make all the nodes the child of the root node which i find in the path while finding the root node for the input node. Now union of two nodes is done by two methods union by rank and union by size, union by size is better as we are able to keep the record of the number of nodes at each step but we are not able to do the same while union by rank. union by rank mein path compression ho raha hai jisse we are not getting the actual number of nodes present in the tree at each step after the union because of the nature of the rank array and how we are increasing it in union_by_rank but union by size mein bhi path compression ho raha hai but still at each step after union tree mein kitne nodes hai we know because of the nature of the size array and how we are increasing it in the union_by_size. See the codes in DSU2.cpp. The time complexity for both union by size and union by rank and find_set() is O(alpha(N)) after using path compression which is approximately equal to O(1) and also this method of making the time complexity getting minimised to O(alpha(N)) by doing path compression is heuristic i.e. there is no mathematical proof of it.

NOTE : A)KRUSKAL'S ALGORITHM : This algorithm helps us to find the weight of all the edges in mst (as it is mst which is a tree so it will be undirected connected graph), here we sort all the edges in the increasing order of the weight so we need the edges array with each edges as ({weight, node1, node2}) and it should be added according to the weight and then normal dsu operation lagana hai, i.e. union by size or union by rank. Now if mst is also asked(i.e. tree is asked) then while we are dealing with a entry in edges array if we are taking it's weight, but for the final mst, in the mst array mein we will also store the ({node1, node2}) of that entry to get the final mst.
The code for it can be seen at https://www.geeksforgeeks.org/problems/minimum-spanning-tree/1 or DSU5.cpp.

B) In questions point of view, if we need to check something while dynamically making the graph then dsu can be helpful as dsu make the graph dynamically (and by dynamically making the graph se matlab hai ki 2 nodes ko join kar kar ke step by step edges ka input leke graph banana and in that proccess if we need to strore some information then this dsu concept is uesful).

C) DSU also helps us to find number of graphs in a forest or say number of components in a graph and also can be used to find cycle in an undirected graph.

8) STRONGLY CONNECTED COMPONENTS(SCC) : This term is only valid for directed graph, when there exist a path between each pair of vertices in a directed graph then such graph is called SCC, also in a graph there can be multiple subset of nodes in a directed graph which in itself are scc. When exist a path between each pair of nodes in a directed graph, such graph is called a connected graph, again there can be multiple subset of nodes in directed graph which itself is a connected components. 


NOTE : A) If we replace each of the SCCs of any directed graph by a single node, we get a SCC-Condensed graph and this SCC-Condensed graph will always be a DAG.
 
B)KOSARAJU'S ALGORITHM :- In this algorithm we find the number of scc's in the graph and the components of each scc and we can apply this only on a directed graph as scc exists only in a directed graph. The steps to do so is first we need to sort the nodes in the order of finishing times of the edges, for that we just need to run a dfs once in the graph and store the nodes in a stack(follows lifo) then we need to reverse the edges of the graph and then we will run a dfs according to the nodes stored in the stack and hence we would get the number of scc and also the components of each scc could be stored. Reversing the edges helps us in the way that when we will run dfs on a node in the stack(which would have nodes stored in descending order of finishing time) then it will cover all the nodes of a particular scc of the graph only, i.e. a node of a SCC-Condensed graph and the number of times dfs has to be called for that stack will be the number of scc in the graph and while making the dfs traversal for nodes in stack we could have stored the components of the scc also. The code can be seen at graph21.cpp or g-54 and have also submitted on gfg.

9) GENERAL TIP :- Whenever you find a problem that involves a directed graph and you can’t solve it by simple BFS/DFS or shortest path algorithms, rethink that problem assuming given graph as a DAG and if you can find a solution to it in that way. Then, you can use SCCs to convert the given directed graph to DAG and then apply your solution to it. 

10) TREE DIAMETER :- it is the maximum number of edges present between any two nodes of the tree, and tree is undirected with no cycles present.

11) BINARY LIFTING :- In this we are given a tree and a node s and we need to find the kth parent of s now will it work for normal graph also or not we need to ponder

12) PRIM'S ALGORITHM(MST) :- Isme this is the problem statement : Given a weighted, undirected, and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree (Sometimes it may be asked to find the MST as well, where in the MST the edge-informations will be stored in the form {u, v}(u = starting node, v = ending node).) Hence it is for a undirected graph although initially jo graph dia hoga usme cycles hoga but when we are done with the algorithm usme cycle nahi hoga as we will get mst which is a tree.
The algo : use a priority queue i.e. min heap and we will input ({wt, node, par}) as obviously minimising the sum is important hence wt is critical for us and hence in order wt comes at first and when we are dealing with a entry in the pq then we will mark the node vis and push all the children's of it in the pq, also it will be done only when then node is not visited, if node is visited then we wont do anything and after we are done doing this we will also store the edge info i.e. node, par of the entry in the mst array to form the final graph and while dealing with every entry we would keep updating the sum variable, at the end we will get the mst stored in the sum, also the mst array will give the tree.
NOTE : By now we understand that this priority queue is very helpful after using it in prim's and Dijkstra. The way we are accessing the entry in the priority queue (min heap), it is just like greedy, in prim's the one with least edge weight was accessed at each iteration, it is nothing but greedy. So we just used a greedy algorithm. Can see g-45 and graph26.cpp 

13) TARJAN'S ALGORITHM(BRIDGES IN A GRAPH) :- This algo helps us to get the all the bridges present in a graph, bridge in a graph is that, after whose removal breaks graph in 2 or more connected components in a graph, now to get this we have to run dfs on the graph and while doing so we maintain two array, one is the tin which stores the insertion time(when is the first time we reached it) of the node in the graph and the other array is low, which stores the minimum lowest insertion time of all adjacent nodes for a node except it's parent and now to know whether a edge between two node is a bride we need to check three things, firstly if that node is getting visited for the first time, then we call dfs of it's adjacent nodes and keep marking the tin and low and once finally dfs will get over at some point and it will backtrack then we will check each edge, if low[it] <= tin[node] then there won't be a bride as it ka koi na koi adjacent node less time mein reachabale hai toh node bhi reach kar sakte hai even if it and node ke beech ka edge hata die toh, for eg if it is at 6 and node is at 8 then it ka koi adjacent node 6 pe inset hua hoga so, 6 to 7 to 8 pahuch sakte hai so it se node pahuchne ka dusra rasta bhi hai so it and node ke beech bridge nahi hua as bride hota toh graph would have broken a there won't be any other route to reach node from it and if second case low[it] > tin[node], then it is obvious that there is a bridge between it and node, as if it is insert at 6 and node is at 5 then there won't be any way if it and node ke beech ka edge is removed as node is before it always now case 1 and 2 was happening while backtracking ki har node ka dfs complete hote jaa raha hai toh checks are being performed but if while running the dfs we get any it(node) which is vis then we just store low array for that node as that it would be part of the path so even if it and node path is removed then also there was a path. This is how bridges in the graph would be stored. can see code here :https://leetcode.com/problems/critical-connections-in-a-network/description/ or graph - 55 of striver playlist can be watched.

14)ARTICULATION POINT : What is an Articulation Point? : An articulation point (or cut vertex) in a graph is a node such that: If you remove this node (and its edges), the graph becomes disconnected (i.e., it breaks into more pieces).
Example:
Imagine a bridge connecting two cities.
If there’s only one road through city X, then removing city X disconnects the two sides.
That city X is an articulation point.
How do we find it? (DFS + tin/low arrays)
We use Depth First Search (DFS) with two helper arrays:
tin[] → time of insertion (when a node was first visited in DFS).
low[] → the earliest discovered node reachable from this node or its subtree using back-edges.
mark[] → to mark if a node is an articulation point.

Step 1: Run DFS
Start DFS, and give each node a timer value (tin[node] = current time).
Initially, low[node] = tin[node].
As you explore neighbors, update low[] accordingly.

Step 2: Parent vs Child in DFS Tree

Case 1: Root of DFS tree
If the root has 2 or more children, it’s an articulation point.
Because if you remove it, those children’s subgraphs are disconnected.

Case 2: Any other node (not root)
If you find a child v of node u such that: low[v] >= tin[u] then u is an articulation point as low[v] tells us the earliest node reachable from v’s subtree and If low[v] >= tin[u], it means that v and its descendants cannot reach back to u’s ancestors without going through u, So, removing u disconnects that part of the graph.

Step 3: Update low values
If you go to an unvisited child, after DFS return:
low[u] = min(low[u], low[v])
If you go to a visited node
low[u] = min(low[u], tin[v])
Intuition :
Think of tin[] as when you entered the city during your trip.
low[] tells you the earliest city you can still go back to without retracing your parent.
If a city’s child cannot “go back” to an earlier city except through its parent, then removing that parent city cuts the map → articulation point.
Can watch g-56 of graph playlist and see code here : https://www.geeksforgeeks.org/problems/articulation-point2616/1

15)MULTISTAGE GRAPH : Multistage graph is a directed graph in which all the edges points towards the same direction, also the nodes in the graph can be divided into multiple stages, i.e. some nodes together can be grouped in a stage, the source node will be in the first stage and the sink nodes will be in the final stage, in this we want to find the shortest distance between source to sink or you can say shortest distance from source to all the nodes, there are two approaches to it, first one being the forward approach, you can see this video https://www.youtube.com/watch?v=C03xPQ3V0os and see the code in A9_2_1.cpp in algorithm design and analysis lab solutions. The next one is the backward approach for this you can watch this video https://www.youtube.com/watch?v=f96ITqUmq-k and see A9_2_2.cpp in algorithm design and analysis lab solutions.

16)TRAVELLING SALESMAN PROBLEM : Given a 2d matrix cost[][] of size n where cost[i][j] denotes the cost of moving from city i to city j. The task is to complete a tour from city 0 (0-based index) to all other cities such that we visit each city exactly once and then at the end come back to city 0 at minimum cost.

NOTE :The difference between Hamiltonian Cycle and TSP. The Hamiltonian cycle problem is to find if there exists a tour that visits every city(all the cities in the graph has to be visited and has to return to initial city for being a Hamiltonian cycle) exactly once. Here we know that Hamiltonian Tour exists (because the graph is complete) and in fact, many such tours exist, the problem is to find a minimum weight Hamiltonian Cycle.

Hamiltonian Path : there is a minor difference between Hamiltonian path and Hamiltonian cycle, in Hamiltonian path we just need to visit all the nodes in the graph exactly once and we need not to return to the starting node but in the case of Hamiltonian cycle we need to return to the starting node also after visiting all the nodes.

We will use dp to solve the problem the code for the same can be seen in graph27.cpp and can watch video from https://www.youtube.com/watch?v=JE0JE8ce1V0 